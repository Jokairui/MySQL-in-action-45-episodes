### Cue

备库复制的基本流程

三种binlog格式之间的差异

循环复制问题是什么，怎么解决

### Notes

#### 基本流程

1. 备库通过change master命令设置主库的相关信息
2. 通过start slave命令开启同步，此时备库会起两个线程，io_thread & sql_thread
3. 主库中有一个专门的线程，负责与备库维持一个长连接，并从本地读取binlog发送给备库
4. io_thread负责接受来自主库的binlog数据，并将其写到磁盘上，称为relay log（中转日志）
5. sql_thread后来发展成了多线程，anyway，它会读取relay log，解析并执行

#### 三种格式binlog对比

|           | 优点                                 | 缺点                                                         |
| --------- | ------------------------------------ | ------------------------------------------------------------ |
| statement | 只存原始语句，节省空间               | 同一条sql在不同的server上执行可能会导致不同的结果            |
| row       | 存放影响行的具体数据，一致性安全保障 | 在一些情况下特别占用空间，例如一次delete 10万行数据，就会存10万行数据到binlog里 |
| mixed     | 目标是结合以上两种格式的优点         | 并没有想象中的那么智能，例如 `insert into t values(10,10, now());`这行语句，它会以statement格式存储原始语句，但是在执行insert之前会执行`set timestamp=XXXX`，如果有个傻子通过copy binlog中的语句来恢复，漏掉了这一句SQL，就会导致数据不一致的风险 |

#### 循环复制的问题

* 定义：备库读取来自主库的binlog之后，生成自己的binlog，主备切换之后，原主库又会读取原备库的binlog再执行一遍
* 解决方法：binlog中执行第一次执行这个事务的server id，MySQL在执行binlog之前先判断server id是否一致，如果一致则直接丢弃

### Summary

了解了主备复制的基本流程，对比了三种不同格式binlog的差异，了解了主备切换导致的循环复制问题的解决。

