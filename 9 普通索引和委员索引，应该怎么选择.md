##  查询过程

例子： SELECT * FROM t WHERE k = 1

*  对于普通索引来说，当查询到满足条件的行后，需要查找下一个记录，知道碰到第一个不满足条件的记录为止
*  对于唯一索引来说，当查询到满足条件的行后，由于自身有唯一性的限制，所以直接返回，不再查找下一条记录



只有当命中的第一条记录为当前数据页的最后一条记录，且下一条记录所在的数据页不在内存中，两者之间的查询性能才会有差别，**但出现这种情况的概率非常低**

##  插入过程

####  change buffer

插入一条数据时，若它所在的数据页不在内存中，则写入change buffer中，而不是将数据页拉入内存，由此提升更新性能

####  merge

当下一次需要读到同一条数据时，会将数据页拉入内存，同时应用change buffer中的操作，这个过程称为merge，merge带来的好处是，将原来的随机IO统一在一起，变成顺序IO，减少了IO次数，增加了单次IO处理的数据量

#### innodb_change_buffer_max_size

设置这个值表示change buffer所占的buffer pool的最大比例



**由于唯一索引的数据必须要保证唯一性，所以插入时必须把数据页拉入内存，所以也就用不上change buffer了**



## 索引和实践

1. 所以将一个普通索引改成一个唯一索引时要慎重，对于写多的业务，可能会导致数据库负载猛增，因为每一次唯一索引的可能会带来IO操作
2. 什么时候使用change buffer呢， 插入的数据不会马上被查询，也就是不会马上出现merge操作的业务场景，例如账单类，日志类的业务，可以尽可能地调大`innodb_change_buffer_max_size`的值，一次merge的数量越大，收益越大

## change buffer 和 redo log

怎么说呢，写change buffer跟写磁盘在这里是一个意义，原来该怎么写redo log现在就还是怎么写。

redo log 主要节省的是随机写磁盘的 IO 消耗（不用每次更新都写入磁盘），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗（不用每次更新都要把数据页拉入内存）



