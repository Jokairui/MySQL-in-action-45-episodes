## 8 事务到底是隔离的还是不隔离的？

### Cue

在RC和RR期间，InnoDB中的MVCC实现机制？

transaction id 、row tax_id、高水位、低水位、活跃事务id数组

什么情况下，会有“大于低水位又小于低水位，却已经提交”的事务

一致性读、当前读

### Notes

#### 两个”视图“

* 一个指MySQL里的虚拟表，创建语法为create view...
* 另一个指InnoDB在实现MVCC时用到的一致性视图，即consistent read view，没有物理结构，用来定义事务执行期间我看到了什么数据

#### 在可重复读隔离级别下，InnoDB中的MVCC是怎么实现一致性视图的？

1. 每一个事务都有一个唯一的transaction id，在事务开始时申请，是严格递增的

2. 每一列数据有一个隐藏列——row trx_id

3. 每一个事务的执行瞬间，会有创建一个数组，存放当前时刻所有活跃的事务id

   * 数组中的最小值定义为低水位min，当前系统中已经创建过的事务id+1为高水位max

   * 对于row trx_id 小于min的行来说，意味着该行对应的事务已提交

   * 对于row trx_id 大于max的行来说，意味这这是来自“未来”的事务提交的数据，不可见，需要通过undo log回滚找到一个可见的值

   * 对于min < row trx_id < max的行来说，如果row trx_id存在数组中，说明不可见，否则，说明改行对应事务已经提交，可见。

     举例：设当前事务创建瞬间，申请到的id为3，且只有1这一个事务活跃，存放到数组中，同时2已经提交，故不存在数组中，之后，还可能会有4，5等事务被创建，那么对于当前事务创建瞬间，min=1，max=4，数组中只有1，3.这个时候就出现了 min<2<max,但是却是一个已提交的事务

     总结：通过上面的例子，可以得出，并不是说大于低水位的事务就一定是未提交事务。

以上，就是InnoDB秒级建快照的方法，利用这一串逻辑，在访问对应行时，可以计算出它应该读到的值。

#### 一致性读

1. 版本未提交，不可见
2. 版本于当前事务启动之后提交，不可见
3. 版本于当前事务启动之前提交，可见。

#### 当前读

给select语句加上 lock in share mode 或 for update，就会变成当前读

不遵循一致性读的原则，总是读取已经提交完成的最新版本，即读到的值不通过undo log进行回滚计算，同时，会给对应行加写锁

#### 在读提交隔离级别下，InnoDB中的MVCC是怎么样的？

当前读的逻辑不变，一致性读逻辑变为

1. 版本未提交，不可见
2. 版本已提交，可见

#### P.S.

`start transcation with consistent snapshot`这个命令可以直接开启一个事务并建立一个一致性视图，否则，只会在第一行SQL开始执行时建立一致性视图，适合用来本地做实验。

### Summary

通过对InnoDB中的MVCC实现机制的剖析，理解了一致性读和当前读这两个概念。故而可以将MVCC的实现机制总结为一致性读+当前读。

注意不同隔离级别下，MVCC的实现见的差异，主要体现在一致性读上。

