### Cue

行锁什么时候加上，什么时候释放？

MySQL是怎么解决行锁死锁问题的？

并发太大导致死锁检测成为性能瓶颈改怎么做？

### Notes

#### 两阶段锁协议

锁在需要的时候加上，但却只能在事务结束的时候释放。所以一个事务中，应当尽可能的把会持有锁的语句后放

#### 解决死锁的策略

1. 超时等待，通过innodb_lock_wait_timeout来设置超时时间
2. 死锁检测，通过设置innodb_deadlock_detect为on

#### 不同死锁策略的缺点

1. 难以设置一个完美的超时等待的时间，太久严重影响性能，太短容易影响正常锁等待
2. 死锁检测是一个O(n)复杂度的操作，会导致CPU使用率猛增，解决方法如下：
   * 确定不会有锁争用的业务，关闭死锁检测
   * 控制并发线程数量，要么通过中间件在入库请排队，要么该MySQL代码限制操作同一行的线程数量
   * 将一行数据改成逻辑上的多行，每次随机选择一行进行操作，分散并发（如果是扣减类的操作，要注意可能有的行值已经为0的情况）

### Summary

了解了行锁的加锁与释放的时机，即两阶段锁协议。了解了两种解决死锁的策略，以及它们的局限性。

学习了死锁检测的优化策略，总的思路是减少并发线程数。