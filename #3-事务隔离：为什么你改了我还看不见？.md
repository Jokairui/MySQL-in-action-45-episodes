### 多个事务并发会出现的问题
1. 脏读（dirty read）：
一个事务执行期间能读到其它事务未提交的变更，导致前后看到的值不一致。
2. 重复读（repeatable read）
一个事务执行期间，对同一个值的查询得到两次不同的结果
3. 幻读（phantom read）
一个事务执行期间，同样的两次查询，第二次结果集与上一次不同，例如结果集多了一列。
### 事务隔离级别
1. 读未提交（Read Uncommitted）：
一个事务执行期间，能看到其它事务还未提交的变更，无法解决脏读问题
2. 读提交（Read Committed）：
一个事务执行期间，只能看到其它事务已提交的变更，无法解决重复读的问题
3. 可重复读（Repeatable Read）：
一个事务执行期间看到的变更，总是跟它启动前看的的变更一致，无法解决幻读的问题。
在可重复读级别下面，开启一个事务回生成一个read-view，所以长事务过多，会导致read-view过多，从而导致回滚段占用大量的资源
其实通过Read View和MVCC的方式，也能解决幻读的问题。    
4. 串行化（Serializable）：
所有的事务都按顺序执行，没有任何并发
### 事务的启动方式
1. 通过显式使用begin或start transaction + commit
2. `set autocommit=0`，直接执行语句，这时便会开启一个事务，会持续到手动commit或者rollback或者断开连接。

可以通过`select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
`查询超过60s的事务