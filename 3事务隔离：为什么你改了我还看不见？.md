### Cue

数据库的事务隔离级别有哪些？

什么是脏读？什么是幻读？

MySQL的事务隔离是如何实现的？

### Notes

#####多个事务并发会出现的问题

1. 脏读（dirty read）：
  一个事务执行期间能读到其它事务未提交的变更，导致前后看到的值不一致。

2. 幻读（phantom read）

  指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内**插入**了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）
#####事务隔离级别

1. 读未提交（Read Uncommitted）：
  一个事务执行期间，能看到其它事务还未提交的变更，无法解决脏读问题

2. 读提交（Read Committed）：
  一个事务执行期间，只能看到其它事务已提交的变更，也无法解决脏读的问题

3. 可重复读（Repeatable Read）：
  一个事务执行期间看到的变更，总是跟它启动前看的的变更一致，无法解决幻读的问题。
  在可重复读级别下面，开启一个事务回生成一个read-view，所以长事务过多，会导致read-view过多，从而导致回滚段占用大量的资源。    

  InnoDB通过MVCC，可以在RR级别下解决幻读的问题

4. 串行化（Serializable）：
  所有的事务都按顺序执行，没有任何并发
##### 事务隔离的实现

读提交下，没有什么机制可言，任何改动都任何事务可见；对于RC和RR，采用视图的方式实现

RR下的MVCC（多版本并发控制），同一行数据在存在多个版本，在不同视图下存在不同值，早些版本的值通过回滚日志来计算得到

#####事务的启动方式

1. 通过显式使用begin或start transaction + commit
2. `set autocommit=0`，直接执行语句，这时便会开启一个事务，会持续到手动commit或者rollback或者断开连接。

可以通过`select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
`查询超过60s的事务



### Summary

了解了事务的4种隔离级别，大体上明白了MySQL事务隔离的实现方式。学习了MVCC的基本概念

